package com.devkbil.mtssbj.common.util;import java.text.DecimalFormat;import java.util.Arrays;import java.util.StringTokenizer;import java.util.Vector;import java.util.regex.Matcher;import java.util.regex.Pattern;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class StringUtil {    /**     * 글자수 자르기     * @param str     * @param limit     * @param tail     * @return     */    public static String cutStr(String str, int limit, String tail) {        String rtnStr = "";        if (str.length() > limit) {            rtnStr = str.substring(0, limit);            if (!"".equals(tail)) {                rtnStr = rtnStr + tail;            }        } else {            rtnStr = str;        }        return rtnStr;    }    public static String nvl(Object obj, String def) {        if (obj == null) {            return def;        }        return obj.toString();    }    public static String evl(Object obj, String def) {        if (obj == null) {            return def;        }        String str = obj.toString();        if (str == null || "".equals(str)) {            str = def;        }        return str;    }    public static String nvlTrim(Object obj, String def) {        if (obj == null) {            return def;        }        String str = obj.toString();        return str.trim();    }    public static String evlTrim(Object obj, String def) {        if (obj == null) {            return def;        }        String str = obj.toString();        if (str == null || "".equals(str)) {            str = def;        }        return str.trim();    }    /**     * 글자수 자르기     * @param str     * @param limit     * @return     */    public static String cutStr(String str, int limit) {        return cutStr(str, limit, "");    }    /**     * 줄바꿈     * @param str     * @return     */    public static String nl2br(String str) {        String strRtn = "";        strRtn = str.replaceAll("\r\n", "\n");        strRtn = strRtn.replaceAll("\r", "<br>");        strRtn = strRtn.replaceAll("\n", "<br>");        return strRtn;    }    /**     * [오퍼레이션명] isStringDouble<br />     * [요약] 문자형 데이터 체크<br />     * @param s     * @return<br />     */    public static boolean isStringDouble(String s) {        try {            Double.parseDouble(s);            return true;        } catch (NumberFormatException e) {            //			logger.error(e.getMessage(), e);            return false;        }    }    /**     * [오퍼레이션명] getString<br />     * [요약] byte 문자열 변환<br />     *     * @param data     * @return<br />     */    public static String getString(byte[] data) {        String result = "";        for (int i = 0; i < data.length; i++) {            result = result + toHex(data[i]);        }        return result;    }    /**     * [오퍼레이션명] toHex<br />     * [요약] 메소드설명<br />     *     * @param b     * @return<br />     */    public static String toHex(int b) {        char[] c = new char[2];        c[0] = toHexNibble((b >> 4) & 0x0f);        c[1] = toHexNibble(b & 0x0f);        return new String(c);    }    /**     * [오퍼레이션명] toHexNibble<br />     * [요약] 메소드설명<br />     *     * @param b     * @return<br />     */    public static char toHexNibble(int b) {        if (b >= 0 && b <= 9) {            return (char)(b + '0');        }        if (b >= 0x0a && b <= 0x0f) {            return (char)(b + 'A' - 10);        }        return '0';    }    /**     * [오퍼레이션명] getSeedString<br />     * [요약] 메소드설명<br />     *     * @param data     * @return<br />     */    public static String getSeedString(byte[] data) {        String result = "";        for (int i = 0; i < data.length; i++) {            result = result + toHex(data[i]);            if (i < data.length - 1) {                result = result + " ";            }        }        return result;    }    /**     * [오퍼레이션명] leftPadZero<br />     * [요약] 메소드설명<br />     *     * @param number     * @param length     * @return<br />     */    public static String leftPadZero(int number, int length) {        return lpad("" + number, length, "0");    }    /**     * [오퍼레이션명] leftPadZero<br />     * [요약] 메소드설명<br />     *     * @param number     * @param length     * @return<br />     */    public static String leftPadZero(String number, int length) {        return lpad(number, length, "0");    }    /**     * [오퍼레이션명] lpad<br />     * [요약] 메소드설명<br />     *     * @param str     * @param len     * @param addStr     * @return<br />     */    public static String lpad(String str, int len, String addStr) {        String result = str;        int templen = len - result.length();        for (int i = 0; i < templen; i++) {            result = addStr + result;        }        return result;    }    /**     * [오퍼레이션명] ntohl<br />     * [요약] 메소드설명<br />     *     * @param byteStream     * @param offset     * @return<br />     */    public static long ntohl(byte[] byteStream, int offset) {        long l1 = (long)(byteStream[offset] & 0xff) << 24;        long l2 = (byteStream[offset + 1] & 0xff) << 16;        long l3 = (byteStream[offset + 2] & 0xff) << 8;        long l4 = (byteStream[offset + 3] & 0xff);        return (l1 | l2 | l3 | l4);    }    /**     * @param s 읽을 문자열     * @param startIdx 읽을 문자열 시작점     * @param bytes 읽을 문자열 길이     * @return 스트링 문자열     */    public static String getByteString(String s, int startIdx, int bytes) {        return new String(s.getBytes(), startIdx, bytes);    }    /**     * @return 시리얼 넘버     */    public static String getSerialNo() {        String serialNo = "";        serialNo = "" + System.currentTimeMillis();        serialNo = serialNo.substring(3, 13);        return serialNo;    }    /** 오브잭트 null // empty 파라메터 변환     * @param str : 검사할 object 값     * @return 변환한 String 값     */    public static String nvlOfObject(Object str) {        return nvlOfObject(str, "");    }    /**     * @param str 검사할 object 값     * @param defaultValue 없을시 ""     * @return 변환한 String 값     */    public static String nvlOfObject(Object str, String defaultValue) {        String returnValue = "";        if (str != null && !"".equals(str)) {            returnValue = str.toString();        }        if (str == null || "".equals(str)) {            returnValue = defaultValue;        }        return returnValue;    }    /**     * 공백 치환 메소드(파일 다운로드)     * @param str     * @return     */    public static String getChangeArray(String str) {        StringBuffer sb = new StringBuffer();        if (str == null) {            return "";        }        for (int i = 0; i < str.length(); i++) {            if (str.charAt(i) != '+') {                sb.append(str.charAt(i));            } else {                sb.append("%20");            }        }        return sb.toString().replaceAll("%28", "(").replaceAll("%29", ")");    }    /**     * [오퍼레이션명] rtrim<br />     * [요약] 오른쪽 공백 제거<br />     *     * @param s     * @return<br />     */    public static String rtrim(String s) {        char[] val = s.toCharArray();        int st = 0;        int len = s.length();        while (st < len && val[len - 1] <= ' ') {            len--;        }        return s.substring(0, len);    }    /**     * printStackTrace를 String 리턴     * @param e     * @return String     */    public static String getStackTraceToString(Throwable e) {        StringBuffer sb = new StringBuffer();        try {            sb.append(e.toString());            sb.append("\n");            StackTraceElement[] element = e.getStackTrace();            for (int i = 0; i < element.length; i++) {                sb.append("\tat");                sb.append(element[i].toString());                sb.append("\n");            }        } catch (Exception ex) {            //			logger.error(ex.getMessage(), ex);            return e.toString();        }        return sb.toString();    }    /**     * [오퍼레이션명] 문자열 분리<br>     * [요약] 문자열에서 특정 문자를 기준으로 나누어 배열로 리턴한다.<br>     *     * @param str 원본문자열     * @param delim 구분문자열     * @return String[] (치환된 문자열)<br>     */    public static String[] split(String str, char delim) {        return split(str, delim, true);    }    /**     * [오퍼레이션명] 문자열 분리<br>     * [요약] 문자열에서 특정 문자를 기준으로 나누어 배열로 리턴한다.<br>     *     * @param str 원본문자열     * @param delim 구분문자     * @param isSkipNull Null생략여부     * @return 치환문자열     */    public static String[] split(String str, char delim, boolean isSkipNull) {        if (str == null) {            return null;        }        String[] arr = null;        String strDelim = String.valueOf(delim);        if (isSkipNull) {            StringTokenizer st = new StringTokenizer(str, strDelim);            arr = new String[st.countTokens()];            for (int i = 0; i < arr.length && st.hasMoreTokens(); i++) {                arr[i] = st.nextToken();            }        } else {            @SuppressWarnings("rawtypes")            Vector vt = new Vector();            boolean setNull = str.startsWith(strDelim);            StringTokenizer st = new StringTokenizer(str, strDelim, true);            while (st.hasMoreTokens()) {                String value = st.nextToken();                if (strDelim.equals(value)) {                    if (setNull) {                        vt.add(null);                    } else {                        setNull = true;                    }                } else {                    vt.add(value);                    setNull = false;                }            }            if (setNull) {                vt.add(null);            }            if (vt.size() > 0) {                arr = new String[vt.size()];                vt.copyInto(arr);            }        }        return arr;    }    /**     * [오퍼레이션명] getAmtDecimalFormat<br>     * [요약] 숫자을 문자열을 3자리 수마다 콤마를 찍어준다.<br>     *     * @param str 원본문자열     * @return 치환문자열     */    public static String getAmtDecimalFormat(String str) {        Double num = Double.parseDouble(str);        DecimalFormat df = new DecimalFormat("#,##0");        return df.format(num);    }    /**     * [오퍼레이션명] getAmtDecimalFormat<br>     * [요약] 숫자을 문자열을 3자리 수마다 콤마를 찍어준다.<br>     * str이 공백으로 오면 0을 리턴한다     *     * @param str 원본문자열     * @param end_str 마지막에_붙여줄_텍스트     * @return 치환된문자열     */    public static String getAmtDecimalFormat(String str, String end_str) {        String return_str = "";        if (!"".equals(str)) {            Double num = Double.parseDouble(str);            DecimalFormat df = new DecimalFormat("#,##0");            return_str = df.format(num) + end_str;        } else {            return_str = return_str + end_str;        }        return return_str;    }    /**     * [오퍼레이션명] getAmtDecimalFormat<br>     * [요약] 숫자을 문자열을 3자리 수마다 콤마를 찍어준다.<br>     * str이 공백으로 오면 0을 리턴한다     *     * 금액을 천원단위를 짤라서 리턴     *     * @param str 원본문자열     * @return 치환된문자열     */    public static String getAmtDecimalFormat_chon(String str) {        String return_str = "";        if (str.length() > 3) {            str = str.substring(0, str.length() - 3);        } else {            str = "0";        }        Double num = Double.parseDouble(str);        DecimalFormat df = new DecimalFormat("#,##0");        return_str = df.format(num);        return return_str;    }    /**     *     * [오퍼레이션명] null2zero     * [요약] 파라미터가 null 이나 "" 이면 0 리턴     *     * @param param     * @return int 0     */    public static int null2zero(String param) {        if (param == null) {            return 0;        }        if (param.trim().equals("")) {            return 0;        }        return Integer.parseInt(param);    }    /**     * [오퍼레이션명] getArryFind<br />     * [요약]  Arry 배열에서 해당 문자열을 찾아서 리턴<br />     *     * @param strArr     * @param s     * @return     */    public static int getArryFind(String[] strArr, String s) {        for (int i = 0; strArr.length > i; i++) {            if (strArr[i].indexOf(s) >= 0) {                return 1;            }        }        return -1;    }    /**     *     * [오퍼레이션명] setAmountHangul     * [요약] 금액 한글 리턴     *     * @param amt     * @return<br />     */    public static String setAmountHangul(String amt) {        StringBuilder result = new StringBuilder();        String[] HAN1 = {"", "일", "이", "삼", "사", "오", "육", "칠", "팔", "구"};        String[] HAN2 = {"", "십", "백", "천"};        String[] HAN3 = {"", "만", "억", "조", "경"};        int len = amt.length();        for (int i = len - 1; i >= 0; i--) {            result.append(HAN1[Integer.parseInt(amt.substring(len - i - 1, len - i))]);            if (Integer.parseInt(amt.substring(len - i - 1, len - i)) > 0) {                result.append(HAN2[i % 4]);            }            if (i % 4 == 0) {                result.append(HAN3[i / 4]);            }        }        return result.toString();    }    /**     *     * [오퍼레이션명] setAmountHangul     * [요약] 금액 한글 리턴 + won파라미터 값을 뒤에 추가함     *            ,  공백일 경우 0으로 리턴     * @param amt     * @return     */    public static String setAmountHangul2(String amt) {        return setAmountHangul2(amt, "");    }    public static String setAmountHangul2(String amt, String won) {        StringBuilder result = new StringBuilder();        String[] HAN1 = {"", "일", "이", "삼", "사", "오", "육", "칠", "팔", "구"};        String[] HAN2 = {"", "십", "백", "천"};        String[] HAN3 = {"", "만", "억", "조", "경"};        int len = amt.length();        for (int i = len - 1; i >= 0; i--) {            result.append(HAN1[Integer.parseInt(amt.substring(len - i - 1, len - i))]);            if (Integer.parseInt(amt.substring(len - i - 1, len - i)) > 0) {                result.append(HAN2[i % 4]);            }            if (i % 4 == 0) {                result.append(HAN3[i / 4]);            }        }        //금액공백일 경우 0으로 넘김        if (len == 0) {            return "0" + won;        }        return result + won;    }    /**     *     * [오퍼레이션명] rmZero     * [요약] 입력받은 String의 앞에 있는 '0'을 없앤다     * ex) "00000490000" --> "490000"     * ex) "000.00" --> "0.00"     *     * @param str     * @return<br />     */    public static String rmZero(String str) {        if (str == null) {            return "";        }        char indexChr = ' ';        int index = 0;        while (index < str.length()) {            if (str.charAt(index) == '0') {                index++;            } else {                indexChr = str.charAt(index);                break;            }        }        if (index < str.length()) {            return str.substring(indexChr == '.' ? index - 1 : index);        } else {            return "0";        }    }    /**     *     * [오퍼레이션명] kindRate     * [요약] 착한대출 수수료 포멧용     *     * @param str     * @return<br />     */    public static String kindRate(String str) {        return (Integer.parseInt(str) / 1000.0) + "";    }    /**     *     * [오퍼레이션명] getDate<br />     * [요약] 오늘 날짜 리턴<br />     * @return <br />     */    public static String getDate() {        // TODO Auto-generated method stub        return DateUtil.getYear() + "년 " + (DateUtil.getMonth() + 1) + "월 " + DateUtil.getDate() + "일";    }    /**     *     * [오퍼레이션명] getPersNo<br />     * [요약] 주민번호 또는 사업자번호 포멧 변경<br />     * 13자리일 경우 주민번호     * 10자리 일 경우 사업자 번호로 포멧변경     * @param pers_no     * @param pers_yn     * @return<br />     */    public static String getPersNo(String pers_no, String pers_yn) {        if (pers_no != null && (!"".equals(pers_no))) {            pers_no = pers_no.replaceAll("-", "");            if ("N".equals(pers_yn) && pers_no.length() == 13) {//주민번호일경우                pers_no = pers_no.substring(0, 6) + "-*******";            } else if (pers_no.length() == 13) {                pers_no = pers_no.substring(0, 6) + "-" + pers_no.substring(6);            }            if (pers_no.length() == 10) {//사업자번호 일경우                pers_no = pers_no.substring(0, 3) + "-" + pers_no.substring(3, 5) + "-" + pers_no.substring(5, 10);            }        }        return pers_no;    }    /**     *     * [오퍼레이션명] setHPFormat<br />     * [요약] 휴대폰번호 포멧 넣음<br />     *     * @param hp_no     * @return<br />     */    public static String setHPFormat(String hp_no) {        String temp_hp = hp_no.replaceAll("-", "");        if (temp_hp.length() == 10) {            temp_hp = temp_hp.substring(0, 3) + "-" + temp_hp.substring(3, 6) + "-" + temp_hp.substring(6, 10);        } else if (temp_hp.length() == 11) {            temp_hp = temp_hp.substring(0, 3) + "-" + temp_hp.substring(3, 7) + "-" + temp_hp.substring(7, 11);        }        return temp_hp;    }    /**     * 주민번호 마스킹     *     * @param str     * @return     */    public static String maskingAccount(String str) {        String replaceString = "";        //replaceString = str.replaceAll("^(..)", "*");        replaceString = str.substring(0, str.length() - 6) + "******";        replaceString = new StringBuilder(replaceString).insert(replaceString.length() - 7, "-").toString();        return replaceString;    }    /**     * 전화번호 마스킹     *     * @param str     * @return     */    public static String maskingPhone(String str) {        //전화번호 ▪ 뒤 4자리 마스킹        //→ (ex) 010 – 8614 - * * * *        String replaceString = "";        replaceString = str;        //정규식으로 패턴 처리 폰 3자리 패턴 안맞으면 리턴        Matcher matcher = Pattern.compile("^(\\d{2,3})-?(\\d{3,4})-?(\\d{4})$").matcher(str);        if (matcher.matches()) {            replaceString = "";            // 하이푼 처리            boolean isHyphen = str.indexOf("-") > -1;            //매칭된 그룹 별로 맞춰서 원하는 부분 마스킹 처리            for (int i = 1; i <= matcher.groupCount(); i++) {                String relpaceTarget = matcher.group(i);                //첫 음자 제외 하고 마스킹 처리                if (i == 3) {                    char[] c = new char[relpaceTarget.length()];                    Arrays.fill(c, '*');                    replaceString = replaceString + String.valueOf(c);                } else {                    replaceString = replaceString + relpaceTarget;                }                //하이푼 패턴                if (isHyphen && i < matcher.groupCount()) {                    replaceString = replaceString + "-";                }            }        }        return replaceString;    }    /**     * 생년월일 마스킹     *     * @param str     * @return     */    public static String maskingBirthday(String str) {        //생년원일▪ 연도를 제외한 나머지 마스킹 처리        //→ (ex) 1982****        String replaceString = "";        //		replaceString = str.replaceAll("^(..)", "*");        //todo 정규식으로 변경 ....        replaceString = str.replaceAll("(?<=^\\d{4,})\\d", "*");        //계좌번호 뒤 6자리만 변경        return replaceString;    }    /**     * 카드번호 마스킹     *     * @param str     * @return     */    public static String maskingCardNumber(String str) {        // 카드번호 : ▪ 뒤 6자리 마스킹        //→ (ex) 5409 – 9523 – 12 * * - * * * *        String replaceString = "";        replaceString = str;        //정규식으로 패턴 처리 폰 3자리 패턴 안맞으면 리턴        Matcher matcher = Pattern.compile("^([0-9]{1,4})\\-([0-9]{1,4})\\-([0-9]{1,2})([0-9]{1,2})\\-([0-9]{1,4})$").matcher(str);        if (matcher.matches()) {            replaceString = "";            System.out.println("여기");            // 하이푼 처리            boolean isHyphen = str.indexOf("-") > -1;            //매칭된 그룹 별로 맞춰서 원하는 부분 마스킹 처리            for (int i = 1; i <= matcher.groupCount(); i++) {                String relpaceTarget = matcher.group(i);                //첫 음자 제외 하고 마스킹 처리                if (i > 3) {                    char[] c = new char[relpaceTarget.length()];                    Arrays.fill(c, '*');                    replaceString = replaceString + String.valueOf(c);                } else {                    replaceString = replaceString + relpaceTarget;                }                //하이푼 패턴                if (isHyphen && i < matcher.groupCount() && i != 3) {                    replaceString = replaceString + "-";                }            }        }        return replaceString;    }    /**     * 직장명 마스킹     *     * @param str     * @return     */    public static String maskingJob(String str) {        //직장명▪ 앞 1자리 제외 마스킹        //→ (ex) 한글 : 국 * * * *, 영문 : K * * * * * *        String replaceString = "";        String pattern = "";        replaceString = str;        pattern = "^(.)(.+)$";        Matcher matcher = Pattern.compile(pattern).matcher(str);        if (matcher.matches()) {            replaceString = "";            //매칭된 그룹 별로 맞춰서 원하는 부분 마스킹 처리            for (int i = 1; i <= matcher.groupCount(); i++) {                String relpaceTarget = matcher.group(i);                //원하는 부분 2번째 그룹부터 이므로...                if (i != 1) {                    char[] c = new char[relpaceTarget.length()];                    Arrays.fill(c, '*');                    replaceString = replaceString + String.valueOf(c);                } else {                    replaceString = replaceString + relpaceTarget;                }            }        }        return replaceString;    }    /**     * 이름 마스킹     *     * @param str     * @return     */    public static String maskingName(String str) {        String replaceString = "";        String pattern = "";        replaceString = str;        //이름이 2자일경우        if (str.length() == 2) {            pattern = "^(.)(.+)$";        } else {            pattern = "^(.)(.+)(.)$";        }        Matcher matcher = Pattern.compile(pattern).matcher(str);        if (matcher.matches()) {            replaceString = "";            //매칭된 그룹 별로 맞춰서 원하는 부분 마스킹 처리            for (int i = 1; i <= matcher.groupCount(); i++) {                String relpaceTarget = matcher.group(i);                //원하는 부분 2번째 그룹부터 이므로...                if (i != 1) {                    char[] c = new char[relpaceTarget.length()];                    Arrays.fill(c, '*');                    replaceString = replaceString + String.valueOf(c);                } else {                    replaceString = replaceString + relpaceTarget;                }            }        }        return replaceString;    }    /**     * 이메일 마스킹     *     * @param str     * @return     */    public static String maskingEmail(String str) {        //이메일 ▪ 앞 2자리 제외 마스킹        //→ (ex) do * * * * *@kbfg.com        String replaceString = "";        replaceString = str;        //정규식으로 패턴 처리 이메일 2글자 이후 패턴 안맞으면 리턴        Matcher matcher = Pattern.compile("^(..)(.*)([@]{1})(.*)$").matcher(str);        if (matcher.matches()) {            replaceString = "";            //매칭된 그룹 별로 맞춰서 원하는 부분 마스킹 처리            for (int i = 1; i <= matcher.groupCount(); i++) {                String relpaceTarget = matcher.group(i);                //원하는 부분 2번째 그룹부터 이므로...                if (i == 2) {                    char[] c = new char[relpaceTarget.length()];                    Arrays.fill(c, '*');                    replaceString = replaceString + String.valueOf(c);                } else {                    replaceString = replaceString + relpaceTarget;                }            }        }        return replaceString;    }    /**     * 주소 마스킹     *     * @param str     * @return     */    public static String maskingAddress(String str) {        //▪ 상세주소 마스킹 (동, 도로명 이하 마스킹)        //주소 : → (ex) 구주소 : 서울시 종로구 내수동 * * * * * * *        //신주소 : 서울시 종로구 새문안로 * * * * * *        String replaceString = "";        replaceString = str;        //정규식으로 패턴 처리 이메일 2글자 이후 패턴 안맞으면 리턴        Matcher matcher = Pattern.compile("^(.*)(\\s)(.*)(\\s)(.*)(\\s)(.*)$").matcher(str);        if (matcher.matches()) {            replaceString = "";            //매칭된 그룹 별로 맞춰서 원하는 부분 마스킹 처리            for (int i = 1; i <= matcher.groupCount(); i++) {                String relpaceTarget = matcher.group(i);                //원하는 부분 2번째 그룹부터 이므로...                if (i == 7) {                    char[] c = new char[relpaceTarget.length()];                    Arrays.fill(c, '*');                    replaceString = replaceString + String.valueOf(c);                } else {                    replaceString = replaceString + relpaceTarget;                }            }        }        return replaceString;    }    /**     * Nvl.     *     * @param value the value     * @return the string     */    public static String nvl(String value) {        return nvl(value, "");    }    /**     * Nvl.     *     * @param value the value     * @param defaultValue the default value     * @return the string     */    public static String nvl(String value, String defaultValue) {        if (isEmpty(value) || "null".equals(value)) {            return defaultValue;        }        return value;    }    /**     * Checks if is empty.     *     * @param value the value     * @return true, if is empty     */    public static boolean isEmpty(String value) {        return (value == null || value.length() == 0);    }    /**     * Checks if is not empty.     *     * @param value the value     * @return true, if is not empty     */    public static boolean isNotEmpty(String value) {        return !isEmpty(value);    }    /**     * [오퍼레이션명] getBytes<br />     * [요약] 문자열  byte 변환<br />     *     * @param data     * @return<br />     */    public byte[] getBytes(String data) {        String[] str = data.split(",");        byte[] result = new byte[str.length];        for (int i = 0; i < result.length; i++) {            result[i] = getHex(str[i]);        }        return result;    }    /**     * [오퍼레이션명] getHex<br />     * [요약] 메소드설명<br />     *     * @param str     * @return<br />     */    public byte getHex(String str) {        str = str.trim();        if (str.length() == 0) {            str = "00";        } else if (str.length() == 1) {            str = "0" + str;        }        str = str.toUpperCase();        return (byte)(getHexNibble(str.charAt(0)) * 16 + getHexNibble(str.charAt(1)));    }    /**     * [오퍼레이션명] getHexNibble<br />     * [요약] 메소드설명<br />     *     * @param c     * @return<br />     */    public byte getHexNibble(char c) {        if (c >= '0' && c <= '9') {            return (byte)(c - '0');        }        if (c >= 'A' && c <= 'F') {            return (byte)(c - 'A' + 10);        }        return 0;    }}